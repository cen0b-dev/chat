<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">

    <title>f0xnet // Secure</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        background: '#000000',
                        surface: '#0F0F0F',
                        surfaceHighlight: '#1C1C1E',
                        primary: '#D14E42',
                        primaryDim: '#8A2C23',
                        statusGreen: '#34C759',
                        statusYellow: '#FFD60A',
                        statusGray: '#8E8E93',
                    },
                    fontFamily: {
                        sans: ['SF Pro Text', '-apple-system', 'BlinkMacSystemFont', 'Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'SF Mono', 'Menlo', 'monospace'],
                    },
                    animation: {
                        'enter-message': 'enterMessage 0.35s cubic-bezier(0.2, 0.9, 0.4, 1.1) forwards',
                        'slide-up-modal': 'slideUpModal 0.5s cubic-bezier(0.32, 0.72, 0, 1) forwards',
                        'fade-in': 'fadeIn 0.6s ease-out forwards',
                        'fade-out': 'fadeOut 0.8s ease-out forwards',
                        'pulse-slow': 'pulseSlow 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'cursor-blink': 'cursorBlink 1s step-end infinite',
                        'mic-pulse': 'micPulse 1.5s ease-in-out infinite',
                    },
                    keyframes: {
                        enterMessage: {
                            '0%': { opacity: '0', transform: 'translateY(10px) scale(0.98)' },
                            '100%': { opacity: '1', transform: 'translateY(0) scale(1)' },
                        },
                        slideUpModal: {
                            '0%': { transform: 'translateY(100%)' },
                            '100%': { transform: 'translateY(0)' },
                        },
                        fadeIn: {
                            '0%': { opacity: '0' },
                            '100%': { opacity: '1' },
                        },
                        fadeOut: {
                            '0%': { opacity: '1', filter: 'blur(0px)' },
                            '100%': { opacity: '0', filter: 'blur(6px)' },
                        },
                        pulseSlow: {
                            '0%, 100%': { opacity: '1' },
                            '50%': { opacity: '0.5' },
                        },
                        cursorBlink: {
                            '0%, 100%': { opacity: '1' },
                            '50%': { opacity: '0' },
                        },
                        micPulse: {
                            '0%': { boxShadow: '0 0 0 0 rgba(209, 78, 66, 0.4)' },
                            '70%': { boxShadow: '0 0 0 10px rgba(209, 78, 66, 0)' },
                            '100%': { boxShadow: '0 0 0 0 rgba(209, 78, 66, 0)' },
                        }
                    }
                }
            }
        }
    </script>

    <style>
        html, body {
            background-color: #000000;
            color: #ffffff;
            position: fixed; 
            width: 100%;
            height: 100%;
            height: 100dvh;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            overscroll-behavior-y: none;
        }

        .scanlines {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(255,255,255,0.015) 50%, rgba(255,255,255,0.015));
            background-size: 100% 3px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.3;
        }

        .glass {
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 0.5px solid rgba(255, 255, 255, 0.08);
        }
        
        .glass-modal {
            background: rgba(22, 22, 24, 0.95);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
        }

        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        /* Safe Areas */
        .pt-safe { padding-top: env(safe-area-inset-top); }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
        .top-spacing { padding-top: calc(60px + env(safe-area-inset-top)); }
        .bottom-spacing { padding-bottom: calc(70px + env(safe-area-inset-bottom)); }

        .search-offset-top {
            top: calc(60px + env(safe-area-inset-top));
        }

        /* --- Message System --- */
        
        .msg-container {
            display: flex;
            flex-direction: column;
            padding: 0 16px;
            padding-top: 10px;
            padding-bottom: 20px;
            will-change: transform;
            transition: filter 0.3s ease;
        }

        .msg-container.blur-mode {
            filter: blur(12px);
        }

        .msg-row {
            display: flex;
            width: 100%;
            position: relative;
            align-items: flex-end;
            margin-bottom: 24px; /* Default generous spacing */
            touch-action: pan-y; /* Allow vertical scroll, handle horizontal in JS */
            transition: transform 0.1s linear; /* Smooth drag */
        }
        
        /* Message Bubbles */
        .msg-bubble {
            position: relative;
            max-width: 85%; /* Slightly wider for code */
            padding: 10px 16px;
            font-size: 15px; /* Slightly smaller for density */
            line-height: 1.5;
            letter-spacing: 0.01em;
            z-index: 2;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            overflow-wrap: break-word;
        }
        
        .msg-user {
            background-color: #D14E42;
            color: white;
            border-radius: 20px 20px 4px 20px;
            margin-left: auto;
        }
        
        .msg-ai {
            background-color: #2C2C2E;
            color: #F2F2F7;
            border-radius: 20px 20px 20px 4px;
            margin-right: auto;
        }

        /* Reply Preview Block */
        .reply-block {
            margin-bottom: 6px;
            padding-left: 8px;
            border-left: 2px solid rgba(255,255,255,0.3);
            font-size: 11px;
            color: rgba(255,255,255,0.7);
            cursor: pointer;
            display: flex;
            flex-direction: column;
        }
        .reply-block .reply-role {
            font-weight: 700;
            text-transform: uppercase;
            font-size: 9px;
            opacity: 0.8;
            margin-bottom: 2px;
        }
        .reply-block .reply-content {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        /* Hacker Stream Style */
        .msg-stream {
            font-family: 'JetBrains Mono', 'Menlo', monospace;
            font-size: 13px;
            color: #34C759; /* Hacker Green during stream */
            background-color: #1a1a1a;
            border: 1px solid #333;
        }
        
        .stream-cursor::after {
            content: 'â–ˆ';
            display: inline-block;
            margin-left: 2px;
            animation: cursorBlink 1s step-end infinite;
            color: #34C759;
        }

        /* Grouping Logic */
        .msg-group-continue { 
            margin-top: -20px; /* Pull closer to previous */
        }
        
        /* When continuing, soften the corners */
        .msg-group-continue .msg-user { border-top-right-radius: 6px; }
        .msg-group-continue .msg-ai { border-top-left-radius: 6px; }

        /* Date Separator */
        .date-separator {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 24px 0;
            position: relative;
        }
        
        .date-pill {
            background: rgba(44, 44, 46, 0.8);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            color: #AEAEB2;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            backdrop-filter: blur(4px);
        }

        /* Timestamps (Hidden on Right) */
        .timestamp-reveal {
            position: absolute;
            right: -80px; /* Hidden offscreen */
            top: 0;
            bottom: 0;
            width: 70px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            font-size: 11px;
            color: #636366;
            font-weight: 500;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        /* Status Line (Delivered/Seen) */
        .status-line {
            width: 100%;
            text-align: right;
            font-size: 11px;
            color: #8E8E93;
            padding-right: 4px;
            margin-top: -20px; /* Pull it up under the bubble */
            margin-bottom: 24px; /* Push next message down */
            font-weight: 500;
            opacity: 0;
            height: 0; /* Animate height to push content */
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        }
        
        .status-visible {
            opacity: 1;
            height: 18px; /* Expand to show */
            margin-top: -20px;
            margin-bottom: 12px;
        }

        /* --- Swipe Reply Icon --- */
        .swipe-reply-icon {
            position: absolute;
            left: -40px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 30px;
            background: #1C1C1E;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #D14E42;
            opacity: 0;
            transition: opacity 0.2s;
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* --- Reply Context Bar --- */
        #reply-bar {
            background: rgba(28, 28, 30, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255,255,255,0.1);
            padding: 8px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            color: #ccc;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            position: absolute;
            bottom: 100%; /* Sits exactly on top of footer */
            left: 0; right: 0;
            z-index: 25;
            display: none; /* JS toggles flex/none */
        }
        
        #reply-bar.active {
            display: flex;
            transform: translateY(0);
        }

        .reply-snippet {
            border-left: 2px solid #D14E42;
            padding-left: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 80%;
        }

        /* --- Sapper UI --- */
        .sapper-ui-container {
            position: absolute;
            bottom: 100px;
            left: 0; right: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            opacity: 0;
            z-index: 50;
            transition: opacity 0.2s;
        }

        .sapper-ring {
            width: 48px; height: 48px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            margin-bottom: 12px;
            position: relative;
        }

        /* SVG Ring for filling */
        .progress-ring__circle {
            transition: stroke-dashoffset 0.1s;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
        }

        /* Sapper Pill */
        .sapper-pill-position {
            bottom: calc(70px + env(safe-area-inset-bottom));
        }

        .typing-dot {
            width: 6px; height: 6px;
            background-color: #AEAEB2;
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .typing-dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }
    </style>
</head>
<body class="antialiased selection:bg-primary/30">

    <div class="scanlines"></div>

    <!-- BOOT SCREEN -->
    <div id="boot-screen" class="fixed inset-0 z-[100] bg-black flex flex-col justify-start p-8 pt-16 font-mono text-xs md:text-sm text-primary overflow-hidden tracking-wide">
        <div id="boot-log" class="space-y-1.5 opacity-90"></div>
        <div class="mt-2 animate-pulse">_</div>
    </div>

    <!-- TOAST -->
    <div id="toast" class="fixed top-24 left-1/2 -translate-x-1/2 z-[90] pointer-events-none opacity-0 transition-all duration-300 transform -translate-y-4 w-auto max-w-[90%]">
        <div class="bg-surfaceHighlight border border-white/10 text-white px-5 py-3 rounded-2xl shadow-2xl flex items-center gap-3 backdrop-blur-md">
            <div class="w-1.5 h-1.5 rounded-full bg-primary shrink-0"></div>
            <span id="toast-message" class="text-xs font-medium tracking-wide">Notification</span>
        </div>
    </div>

    <!-- LOGIN -->
    <div id="login-screen" class="hidden fixed inset-0 z-50 bg-black/95 backdrop-blur-xl flex flex-col items-center justify-center p-6 transition-opacity duration-700">
        <div class="w-full max-w-sm flex flex-col items-center space-y-12 transform -translate-y-8">
            <div class="relative w-24 h-24 flex items-center justify-center">
                <i class="ph-fill ph-fox-logo text-7xl text-primary drop-shadow-2xl"></i>
            </div>
            <div class="text-center space-y-1">
                <h1 class="text-2xl font-bold tracking-tight text-white">f0xnet</h1>
                <p class="text-[11px] text-gray-500 font-medium tracking-widest uppercase">Secure Comms Relay</p>
            </div>
            <div class="w-full space-y-4">
                <div class="bg-white/5 border border-white/10 rounded-2xl px-4 py-1 flex items-center">
                    <i class="ph ph-lock-key text-gray-500 mr-3"></i>
                    <input type="password" id="login-pass" class="w-full bg-transparent text-center text-white py-3 focus:outline-none placeholder-gray-700 font-mono text-lg tracking-[0.3em]" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢" inputmode="numeric">
                </div>
                <button onclick="Auth.login()" class="w-full py-4 bg-primary text-white rounded-2xl font-semibold active:scale-[0.98] transition-all text-sm uppercase tracking-wider">Authenticate</button>
            </div>
        </div>
    </div>

    <!-- MAIN APP -->
    <div id="app-interface" class="hidden h-full w-full relative">
        <header class="absolute top-0 left-0 right-0 z-30 glass pt-safe" id="main-header">
            <div class="h-[60px] w-full flex items-center justify-between px-4">
                <div class="flex items-center gap-3" id="header-identity">
                    <div class="relative" id="avatar-btn">
                        <div class="w-9 h-9 rounded-full bg-surfaceHighlight flex items-center justify-center border border-white/5 overflow-hidden">
                            <i class="ph-fill ph-user text-gray-400"></i>
                        </div>
                        <div id="status-dot" class="absolute bottom-0 right-0 w-2.5 h-2.5 rounded-full bg-statusGray border-2 border-[#101010]"></div>
                    </div>
                    <div class="flex flex-col">
                        <span id="contact-name" class="text-white font-semibold text-[15px] leading-tight tracking-tight">f0xnet</span>
                        <span id="connection-status" class="text-[11px] text-gray-500 font-medium leading-none mt-0.5 transition-colors duration-300">Offline</span>
                    </div>
                </div>
                <div class="flex items-center gap-3">
                    <button onclick="Chat.clearHistory()" class="w-9 h-9 flex items-center justify-center rounded-full text-gray-400 active:bg-white/5 active:text-red-500 transition-colors">
                         <i class="ph ph-trash text-xl"></i>
                    </button>
                    <button onclick="UI.toggleSearch()" class="w-9 h-9 flex items-center justify-center rounded-full text-gray-400 active:bg-white/5">
                        <i class="ph ph-magnifying-glass text-xl"></i>
                    </button>
                </div>
            </div>
        </header>

        <div id="search-bar-container" class="hidden absolute left-0 right-0 z-20 bg-black/90 backdrop-blur-md border-b border-white/5 px-4 py-2 search-offset-top">
            <div class="bg-white/10 rounded-xl flex items-center px-3 py-2">
                <i class="ph ph-magnifying-glass text-gray-500 mr-2"></i>
                <input type="text" id="search-input" placeholder="Search..." class="w-full bg-transparent text-white text-sm focus:outline-none" oninput="UI.handleSearch(this.value)">
                <button onclick="UI.toggleSearch()" class="text-gray-500 ml-2"><i class="ph-bold ph-x"></i></button>
            </div>
        </div>

        <!-- SAPPER MODE UI (Instagram Style) -->
        <div class="sapper-ui-container" id="sapper-ui">
            <div class="sapper-ring">
                <!-- SVG Circle for Progress & Track -->
                <svg class="progress-ring" width="48" height="48">
                     <!-- Track -->
                     <circle stroke="rgba(255,255,255,0.1)" stroke-width="4" fill="transparent" r="20" cx="24" cy="24" />
                     <!-- Progress -->
                    <circle class="progress-ring__circle" stroke="#D14E42" stroke-width="4" fill="transparent" r="20" cx="24" cy="24" stroke-dasharray="125.6" stroke-dashoffset="125.6" id="sapper-progress"/>
                </svg>
                <i class="ph-fill ph-ghost text-white text-lg absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2" id="sapper-icon"></i>
            </div>
            <span class="text-[11px] font-medium tracking-wide text-white/70" id="sapper-text">Swipe up for Sapper Mode</span>
        </div>

        <main id="chat-container" class="absolute inset-0 z-0 overflow-hidden top-spacing bottom-spacing bg-black">
            <div id="drag-wrapper" class="w-full h-full overflow-y-auto no-scrollbar relative touch-pan-y">
                
                <!-- Messages Container (Transform target) -->
                <div id="messages-list" class="msg-container"></div>
                
                <div id="typing-indicator" class="hidden w-full px-4 flex mb-6 mt-2 ml-1">
                    <!-- Adjusted height to h-[44px] and radius to rounded-[21px] to match message bubbles -->
                    <div class="bg-[#2C2C2E] rounded-[21px] px-4 h-[44px] flex gap-1 items-center">
                        <div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>
                    </div>
                </div>
                <div id="bottom-anchor" class="h-8"></div>
            </div>
        </main>

        <!-- Sapper Mode Pill -->
        <div id="sapper-pill" class="hidden absolute sapper-pill-position left-1/2 -translate-x-1/2 z-20 bg-primary/10 border border-primary/40 backdrop-blur-md px-4 py-1.5 rounded-full flex items-center gap-2 pointer-events-none">
            <div class="w-1.5 h-1.5 rounded-full bg-primary animate-pulse"></div>
            <span class="text-[10px] font-bold tracking-wider text-primary uppercase">Sapper Active</span>
        </div>

        <footer class="absolute bottom-0 left-0 right-0 z-30 bg-[#161618]/95 backdrop-blur-xl border-t border-white/5 pb-safe" id="main-footer">
            
            <!-- Reply Context Bar -->
            <div id="reply-bar">
                <div class="flex items-center gap-2 overflow-hidden w-full">
                    <i class="ph-bold ph-arrow-u-up-left text-primary"></i>
                    <div class="flex flex-col overflow-hidden">
                        <span class="text-[10px] font-bold text-gray-500 uppercase">Replying to</span>
                        <span id="reply-text-preview" class="reply-snippet text-[11px] text-white"></span>
                    </div>
                </div>
                <button onclick="UI.cancelReply()" class="w-6 h-6 flex items-center justify-center rounded-full bg-white/10 text-gray-400">
                    <i class="ph-bold ph-x text-xs"></i>
                </button>
            </div>

            <div id="attachment-preview" class="hidden px-4 py-2 flex gap-2 overflow-x-auto"></div>
            <div class="flex items-end gap-2 px-4 py-3 max-w-2xl mx-auto">
                <input type="file" id="media-upload" class="hidden" accept="image/*" onchange="UI.handleFileSelect(this)">
                
                <button onclick="document.getElementById('media-upload').click()" class="w-9 h-9 flex-shrink-0 flex items-center justify-center rounded-full bg-surfaceHighlight text-gray-400">
                    <i class="ph-bold ph-plus text-lg"></i>
                </button>

                <!-- Voice Dictation Button -->
                <button id="mic-btn" onclick="Voice.toggle()" class="w-9 h-9 flex-shrink-0 flex items-center justify-center rounded-full bg-surfaceHighlight text-gray-400 active:text-primary transition-all">
                    <i class="ph-bold ph-microphone text-lg"></i>
                </button>

                <div class="flex-1 min-h-[40px] bg-[#1C1C1E] rounded-[20px] border border-white/5 flex items-center px-4 py-1.5 focus-within:border-primary/50 transition-colors">
                    <textarea id="message-input" rows="1" class="w-full bg-transparent text-white placeholder-[#636366] focus:outline-none resize-none max-h-32 text-[16px] leading-tight py-1" placeholder="f0xnet Message" oninput="UI.autoResize(this)" onkeydown="UI.handleEnter(event)"></textarea>
                </div>
                <button onclick="Chat.send()" id="send-btn" class="w-9 h-9 flex-shrink-0 rounded-full bg-primary text-white flex items-center justify-center shadow-md active:scale-90 transition-transform">
                    <i class="ph-bold ph-arrow-up text-lg"></i>
                </button>
            </div>
        </footer>
    </div>

    <!-- SETTINGS -->
    <div id="settings-modal" class="hidden fixed inset-0 z-[60]">
        <div class="absolute inset-0 bg-black/60 backdrop-blur-sm" onclick="UI.toggleSettings()"></div>
        <div class="absolute bottom-0 left-0 right-0 glass-modal rounded-t-[32px] max-h-[90vh] overflow-hidden flex flex-col shadow-2xl animate-slide-up-modal ring-1 ring-white/10">
            <div class="w-full flex justify-center pt-3 pb-2" onclick="UI.toggleSettings()">
                <div class="w-10 h-1 bg-gray-600/40 rounded-full"></div>
            </div>
            <div class="flex-1 overflow-y-auto p-6 space-y-6 pb-12">
                <div class="flex justify-between items-center">
                    <h2 class="text-lg font-semibold text-white">Secure Configuration</h2>
                    <button onclick="UI.toggleSettings()" class="w-8 h-8 rounded-full bg-surfaceHighlight flex items-center justify-center text-gray-400">
                        <i class="ph-bold ph-x"></i>
                    </button>
                </div>
                <div class="w-full bg-surfaceHighlight border border-white/5 rounded-xl p-4 flex items-center gap-4">
                    <div class="w-10 h-10 rounded-full bg-primary/20 flex items-center justify-center">
                        <i class="ph-fill ph-shield-check text-primary text-xl"></i>
                    </div>
                    <div>
                        <div class="text-sm font-semibold text-white">End-to-End Tunnel</div>
                        <div class="text-[11px] text-gray-500 uppercase tracking-widest">Active State</div>
                    </div>
                </div>
                <div class="space-y-2">
                    <label class="text-[11px] font-semibold text-gray-500 uppercase tracking-wide ml-1">Gemini Uplink Key</label>
                    <input type="password" id="api-key-input" class="w-full bg-surfaceHighlight border border-white/5 rounded-xl p-4 text-white text-sm focus:border-primary focus:outline-none font-mono" placeholder="API Key..." oninput="Settings.handleKeyInput(this.value)">
                </div>
                <div class="space-y-2">
                    <div class="flex justify-between px-1"><label class="text-[11px] font-semibold text-gray-500 uppercase tracking-wide">Model Node</label><span id="model-status" class="text-[10px] text-gray-500">Standby</span></div>
                    <select id="model-select" class="w-full bg-surfaceHighlight border border-white/5 rounded-xl p-4 text-white text-sm focus:border-primary focus:outline-none appearance-none">
                        <option value="" disabled selected>Waiting for Key...</option>
                    </select>
                </div>
                <div class="space-y-4">
                    <div class="space-y-2">
                        <label class="text-[11px] font-semibold text-gray-500 uppercase tracking-wide ml-1">Contact Alias</label>
                        <input type="text" id="ai-name-input" class="w-full bg-surfaceHighlight border border-white/5 rounded-xl p-4 text-white text-sm focus:border-primary focus:outline-none">
                    </div>
                    <div class="space-y-2">
                        <label class="text-[11px] font-semibold text-gray-500 uppercase tracking-wide ml-1">System Directives</label>
                        <textarea id="system-prompt" rows="3" class="w-full bg-surfaceHighlight border border-white/5 rounded-xl p-4 text-sm text-gray-300 font-mono focus:border-primary focus:outline-none"></textarea>
                    </div>
                </div>
                <button onclick="Settings.save()" class="w-full py-4 bg-white text-black font-bold rounded-xl active:scale-[0.98] transition-transform">Save Configuration</button>
                <div class="flex flex-col gap-2 pt-2">
                    <button onclick="Settings.wipeData()" class="w-full py-3 text-red-500 text-xs font-semibold rounded-xl">Factory Wipe</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const DEFAULTS = {
            aiName: "f0xnet",
            systemPrompt: "You are a secure contact. Keep messages concise and natural. Use lowercase occasionally. Don't sound robotic.",
            model: "gemini-1.5-flash",
            apiKey: "",
            password: "",
            lastActive: Date.now(),
            sapperMode: false
        };

        const State = {
            config: { ...DEFAULTS },
            history: [],
            isFirstLoad: true,
            attachment: null,
            tapCount: 0,
            tapTimer: null,
            sapperTriggered: false,
            followUpDepth: 0,
            stopFollowUps: false,
            isStreaming: false, 
            replyingTo: null,

            load() {
                const c = localStorage.getItem('f0x_config_v8');
                const h = localStorage.getItem('f0x_history_v8');
                if(c) { this.config = JSON.parse(c); this.isFirstLoad = false; }
                if(h) { this.history = JSON.parse(h); }
            },
            save() {
                localStorage.setItem('f0x_config_v8', JSON.stringify(this.config));
                localStorage.setItem('f0x_history_v8', JSON.stringify(this.history));
            },
            reset() {
                localStorage.clear();
                location.reload();
            }
        };

        const UI = {
            els: {
                msgList: document.getElementById('messages-list'),
                scroll: document.getElementById('drag-wrapper'),
                input: document.getElementById('message-input'),
                search: document.getElementById('search-bar-container'),
                replyBar: document.getElementById('reply-bar'),
                replyPreview: document.getElementById('reply-text-preview')
            },

            haptic(type = 'light') {
                if (!navigator.vibrate) return;
                if (type === 'light') navigator.vibrate(5);
                if (type === 'medium') navigator.vibrate(15);
                if (type === 'heavy') navigator.vibrate([15, 30, 15]);
                if (type === 'tick') navigator.vibrate(2);
            },

            showApp() {
                document.getElementById('login-screen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('login-screen').classList.add('hidden');
                    document.getElementById('app-interface').classList.remove('hidden');
                    this.refresh();
                    this.initSapperGesture();
                    this.initDragToReveal();
                    this.initPrivacyToggle();
                    this.initAvatarStealth();
                    
                    document.getElementById('sapper-pill').classList.toggle('hidden', !State.config.sapperMode);
                }, 700);
            },

            initAvatarStealth() {
                document.getElementById('avatar-btn').addEventListener('click', () => {
                    this.haptic();
                    State.tapCount++;
                    if(State.tapTimer) clearTimeout(State.tapTimer);
                    if(State.tapCount >= 3) {
                        this.toggleSettings();
                        State.tapCount = 0;
                    } else {
                        State.tapTimer = setTimeout(() => State.tapCount = 0, 500);
                    }
                });
            },

            initPrivacyToggle() {
                let lastTap = 0;
                document.getElementById('drag-wrapper').addEventListener('click', (e) => {
                    if(e.target.closest('.msg-bubble') || e.target.closest('button')) return;
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;
                    if (tapLength < 300 && tapLength > 0) {
                        this.toggleBlurMode();
                        e.preventDefault();
                    }
                    lastTap = currentTime;
                });
            },

            toggleBlurMode() {
                this.haptic('medium');
                this.els.msgList.classList.toggle('blur-mode');
                const isBlurred = this.els.msgList.classList.contains('blur-mode');
                this.toast(isBlurred ? "Privacy Veil Active" : "Privacy Veil Lifted");
            },

            // --- Swipe to Reply Logic ---
            initSwipeToReply(row, msgData) {
                let startX = 0;
                let currentTranslate = 0;
                let isSwiping = false;
                const threshold = 60; // drag distance to trigger

                row.addEventListener('touchstart', (e) => {
                    // Ignore if interacting with inner elements or scrolling
                    if(e.target.closest('button')) return;
                    startX = e.touches[0].clientX;
                    row.style.transition = 'none'; // remove transition for direct 1:1 movement
                }, {passive: true});

                row.addEventListener('touchmove', (e) => {
                    const diff = e.touches[0].clientX - startX;
                    // Only allow dragging Right (positive)
                    if (diff > 0 && diff < 150) { 
                        currentTranslate = diff;
                        isSwiping = true;
                        
                        // Resistance curve
                        const resisted = Math.pow(diff, 0.85); 
                        row.style.transform = `translateX(${resisted}px)`;

                        // Show icon opacity based on drag
                        const icon = row.querySelector('.swipe-reply-icon');
                        if(icon) icon.style.opacity = Math.min(diff / threshold, 1);
                    }
                }, {passive: true});

                row.addEventListener('touchend', (e) => {
                    row.style.transition = 'transform 0.2s ease-out';
                    row.style.transform = 'translateX(0)';
                    const icon = row.querySelector('.swipe-reply-icon');
                    if(icon) icon.style.opacity = '0';

                    if (isSwiping && currentTranslate > threshold) {
                        this.haptic('medium');
                        this.setReplyContext(msgData);
                    }
                    
                    isSwiping = false;
                    currentTranslate = 0;
                });
            },

            setReplyContext(msg) {
                State.replyingTo = msg;
                this.els.replyPreview.textContent = msg.text.substring(0, 50) + (msg.text.length > 50 ? '...' : '');
                this.els.replyBar.classList.add('active');
                this.els.input.focus();
            },

            cancelReply() {
                State.replyingTo = null;
                this.els.replyBar.classList.remove('active');
            },
            
            scrollToMsg(id) {
                const el = document.getElementById(`msg-${id}`);
                if(el) {
                    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    el.classList.add('bg-white/5');
                    setTimeout(() => el.classList.remove('bg-white/5'), 1000);
                }
            },

            initSapperGesture() {
                const el = this.els.scroll;
                let startY = 0;
                let isDragging = false;
                const threshold = 150;
                
                const ui = document.getElementById('sapper-ui');
                const progressCircle = document.getElementById('sapper-progress');
                const icon = document.getElementById('sapper-icon');
                const text = document.getElementById('sapper-text');
                const circumference = progressCircle.r.baseVal.value * 2 * Math.PI;

                progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
                progressCircle.style.strokeDashoffset = circumference;

                el.addEventListener('touchstart', e => {
                    if (el.scrollHeight - el.scrollTop - el.clientHeight < 20) {
                        startY = e.touches[0].clientY;
                        isDragging = true;
                        State.sapperTriggered = false;
                    }
                }, {passive: true});

                el.addEventListener('touchmove', e => {
                    if (!isDragging) return;
                    const diff = startY - e.touches[0].clientY;
                    
                    if (diff > 0) {
                        const progress = Math.min(diff / threshold, 1);
                        ui.style.opacity = progress;
                        ui.style.transform = `translateY(-${diff * 0.4}px)`;
                        const offset = circumference - (progress * circumference);
                        progressCircle.style.strokeDashoffset = offset;

                        if (progress >= 1 && !State.sapperTriggered) {
                            State.sapperTriggered = true;
                            this.haptic('medium');
                            text.textContent = "Release to Toggle Sapper";
                            icon.className = "ph-fill ph-check-circle text-primary text-2xl absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2";
                        } else if (progress < 1) {
                            State.sapperTriggered = false;
                            text.textContent = State.config.sapperMode ? "Swipe up to disable Sapper" : "Swipe up for Sapper Mode";
                            icon.className = "ph-fill ph-ghost text-white text-lg absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2";
                        }
                    }
                }, {passive: true});

                el.addEventListener('touchend', () => {
                    isDragging = false;
                    ui.style.opacity = '0';
                    ui.style.transform = `translateY(0)`;
                    if (State.sapperTriggered) {
                        this.toggleSapperMode();
                    }
                    State.sapperTriggered = false;
                });
            },

            initDragToReveal() {
                const wrapper = document.getElementById('drag-wrapper');
                const list = document.getElementById('messages-list');
                let startX = 0;

                wrapper.addEventListener('touchstart', e => { startX = e.touches[0].clientX; }, {passive: true});

                wrapper.addEventListener('touchmove', e => {
                    const currentX = e.touches[0].clientX;
                    const diff = currentX - startX;
                    if (diff < -10) { 
                        const offset = Math.min(Math.abs(diff) * 0.6, 85); 
                        list.style.transform = `translateX(-${offset}px)`;
                        const opacity = Math.min(offset / 60, 1);
                        document.querySelectorAll('.timestamp-reveal').forEach(el => el.style.opacity = opacity);
                    }
                }, {passive: true});

                wrapper.addEventListener('touchend', () => {
                    list.style.transform = `translateX(0)`;
                    document.querySelectorAll('.timestamp-reveal').forEach(el => el.style.opacity = '0');
                });
            },

            toggleSapperMode() {
                this.haptic('heavy');
                State.config.sapperMode = !State.config.sapperMode;
                State.save();
                document.body.classList.toggle('sapper-mode-active', State.config.sapperMode);
                document.getElementById('sapper-pill').classList.toggle('hidden', !State.config.sapperMode);
                
                if(State.config.sapperMode) {
                    this.renderMsg('system', 'SAPPER ACTIVE: MESSAGES VANISH IN 60s');
                    document.body.classList.add('animate-pulse-slow');
                    setTimeout(() => document.body.classList.remove('animate-pulse-slow'), 1000);
                } else {
                    this.renderMsg('system', 'SAPPER DEACTIVATED');
                }
            },

            refresh() {
                document.getElementById('contact-name').textContent = State.config.aiName;
                document.getElementById('api-key-input').value = State.config.apiKey || '';
                document.getElementById('ai-name-input').value = State.config.aiName;
                document.getElementById('system-prompt').value = State.config.systemPrompt;
                this.renderHistory(State.history);
            },

            getDateLabel(ts) {
                const d = new Date(ts);
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
                const yesterday = new Date(today - 86400000).getTime();
                const msgDay = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();

                if (msgDay === today) return "Today";
                if (msgDay === yesterday) return "Yesterday";
                return d.toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' });
            },

            renderDateSeparator(label) {
                const div = document.createElement('div');
                div.className = 'date-separator';
                div.innerHTML = `<span class="date-pill">${label}</span>`;
                this.els.msgList.appendChild(div);
            },

            renderHistory(msgs) {
                this.els.msgList.innerHTML = '';
                const now = Date.now();
                const validMsgs = msgs.filter(m => !m.expiresAt || m.expiresAt > now);
                
                let lastDateLabel = null;

                validMsgs.forEach((msg, i) => {
                    const label = this.getDateLabel(msg.id);
                    if (label !== lastDateLabel) {
                        this.renderDateSeparator(label);
                        lastDateLabel = label;
                    }

                    const prev = validMsgs[i-1];
                    this.renderMsg(msg.role, msg.text, false, msg, prev?.role);
                });
                
                const lastMsg = validMsgs[validMsgs.length - 1];
                if(lastMsg && lastMsg.role === 'user') {
                    this.appendStatus(true);
                }

                this.scrollToBottom();
            },

            renderMsg(role, text, animate = true, msgObj = null, prevRole = null) {
                if(role === 'system') {
                    const div = document.createElement('div');
                    div.className = 'text-[10px] text-center text-gray-600 uppercase tracking-widest py-6 animate-fade-in font-mono';
                    div.innerHTML = `<span class="bg-black px-2">${text}</span>`;
                    this.els.msgList.appendChild(div);
                    return;
                }

                const row = document.createElement('div');
                row.className = 'msg-row';
                if(msgObj) {
                    row.id = `msg-${msgObj.id}`;
                    // Only Init Swipe if NOT user role
                    if(msgObj.role !== 'user') this.initSwipeToReply(row, msgObj); 
                }
                if (prevRole === role) row.classList.add('msg-group-continue');

                // Swipe Icon (Only if AI)
                if(role !== 'user') {
                    const swipeIcon = document.createElement('div');
                    swipeIcon.className = 'swipe-reply-icon';
                    swipeIcon.innerHTML = '<i class="ph-bold ph-arrow-bend-up-left"></i>';
                    row.appendChild(swipeIcon);
                }

                const bubble = document.createElement('div');
                bubble.className = `msg-bubble ${role === 'user' ? 'msg-user' : 'msg-ai'} ${animate ? 'animate-enter-message' : ''}`;
                
                // Reply Block Injection
                let contentHTML = '';
                if(msgObj && msgObj.replyTo) {
                    contentHTML += `
                        <div class="reply-block" onclick="UI.scrollToMsg(${msgObj.replyTo.id})">
                            <span class="reply-role">${msgObj.replyTo.role === 'user' ? 'You' : State.config.aiName}</span>
                            <span class="reply-content">${msgObj.replyTo.text.replace(/!\[Image\]\(.*?\)/, 'ðŸ“· Image')}</span>
                        </div>
                    `;
                }

                if (animate && role === 'model') {
                    // Start with reply block if exists, text injected by stream
                    bubble.innerHTML = contentHTML; 
                } else {
                    contentHTML += `<div class="prose prose-invert prose-sm">${marked.parse(text)}</div>`;
                    bubble.innerHTML = contentHTML;
                }

                const stamp = document.createElement('div');
                stamp.className = 'timestamp-reveal';
                const timeStr = new Date(msgObj ? msgObj.id : Date.now()).toLocaleTimeString([], {hour:'numeric', minute:'2-digit'});
                stamp.textContent = timeStr;

                row.appendChild(bubble);
                row.appendChild(stamp);
                this.els.msgList.appendChild(row);

                if (msgObj?.expiresAt) {
                    const delay = msgObj.expiresAt - Date.now();
                    if(delay > 0) {
                        setTimeout(() => {
                            row.classList.add('animate-fade-out');
                            setTimeout(() => { row.remove(); }, 800);
                        }, delay);
                    }
                }

                this.scrollToBottom();
                return bubble;
            },

            // --- Decryption Effect Stream ---
            async decryptStream(element, text) {
                State.isStreaming = true; 
                element.classList.add('msg-stream', 'stream-cursor');
                element.classList.remove('msg-ai'); 
                element.style.borderRadius = "20px 20px 20px 4px";
                
                // Preserve Reply Block if it exists
                const replyBlock = element.querySelector('.reply-block');
                const replyHTML = replyBlock ? replyBlock.outerHTML : '';
                
                const chars = text.split('');
                const hackerChars = "!@#$%^&*()_+-=[]{}|;':\",./<>?";
                let currentText = "";

                // Stream loop
                for (let i = 0; i < chars.length; i++) {
                    if (!State.isStreaming) break; 
                    
                    // Add next real char
                    currentText += chars[i];
                    
                    // Decryption Visual: Render clean text + 3 random chars at end
                    let randomSuffix = "";
                    for(let k=0; k<3; k++) randomSuffix += hackerChars[Math.floor(Math.random() * hackerChars.length)];
                    
                    // Re-inject reply block every frame to keep it visible
                    element.innerHTML = replyHTML + currentText + randomSuffix;
                    
                    const delay = Math.random() < 0.1 ? 30 : (Math.random() < 0.5 ? 10 : 20);
                    if (i % 3 === 0) this.scrollToBottom();
                    await new Promise(r => setTimeout(r, delay));
                }

                if (State.isStreaming) {
                    await new Promise(r => setTimeout(r, 150)); 
                    element.classList.remove('msg-stream', 'stream-cursor');
                    element.classList.add('msg-ai');
                    // Final Clean Render
                    element.innerHTML = replyHTML + `<div class="prose prose-invert prose-sm animate-fade-in">${marked.parse(text)}</div>`;
                    this.scrollToBottom();
                    this.haptic('medium');
                    State.isStreaming = false; 
                } else {
                    element.classList.remove('stream-cursor'); 
                }
            },

            appendStatus(animate = true) {
                const existing = document.getElementById('status-label');
                if(existing) existing.remove();
                const rows = document.querySelectorAll('.msg-row');
                if(rows.length === 0) return;
                const lastRow = rows[rows.length - 1];
                if(!lastRow.querySelector('.msg-user')) return;
                const statusDiv = document.createElement('div');
                statusDiv.id = 'status-label';
                statusDiv.className = 'status-line';
                statusDiv.innerHTML = 'Delivered';
                lastRow.after(statusDiv);
                if(animate) {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => statusDiv.classList.add('status-visible'));
                    });
                } else {
                    statusDiv.classList.add('status-visible');
                }
            },

            updateStatusText(text) {
                const el = document.getElementById('status-label');
                if(el) { el.textContent = text; el.classList.add('status-visible'); }
            },

            scrollToBottom() {
                requestAnimationFrame(() => {
                     this.els.scroll.scrollTop = this.els.scroll.scrollHeight;
                });
            },

            showTyping(show) {
                const ind = document.getElementById('typing-indicator');
                if(show) {
                    ind.classList.remove('hidden');
                    this.scrollToBottom();
                } else {
                    ind.classList.add('hidden');
                }
            },

            toggleSettings() { this.haptic(); document.getElementById('settings-modal').classList.toggle('hidden'); },

            toggleSearch() {
                this.haptic();
                this.els.search.classList.toggle('hidden');
                if(!this.els.search.classList.contains('hidden')) document.getElementById('search-input').focus();
                else this.renderHistory(State.history);
            },

            handleSearch(query) {
                if(!query) { this.renderHistory(State.history); return; }
                const filtered = State.history.filter(m => m.text.toLowerCase().includes(query.toLowerCase()));
                this.els.msgList.innerHTML = '';
                filtered.forEach(msg => this.renderMsg(msg.role, msg.text, false, msg));
            },

            handleFileSelect(input) {
                const file = input.files[0];
                if(!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    State.attachment = { mimeType: file.type, data: e.target.result.split(',')[1], url: e.target.result };
                    const area = document.getElementById('attachment-preview');
                    area.classList.remove('hidden');
                    area.innerHTML = `<div class="relative"><img src="${e.target.result}" class="h-16 w-16 object-cover rounded-xl border border-white/20"><button onclick="UI.clearAttachment()" class="absolute -top-1.5 -right-1.5 bg-gray-800 rounded-full w-5 h-5 flex items-center justify-center text-xs shadow-lg"><i class="ph-bold ph-x"></i></button></div>`;
                };
                reader.readAsDataURL(file);
            },

            clearAttachment() {
                State.attachment = null;
                const area = document.getElementById('attachment-preview');
                area.innerHTML = ''; area.classList.add('hidden');
            },

            toast(msg) {
                this.haptic();
                const t = document.getElementById('toast');
                document.getElementById('toast-message').textContent = msg;
                t.classList.remove('opacity-0', '-translate-y-4');
                t.classList.add('opacity-100', 'translate-y-0');
                setTimeout(() => { 
                    t.classList.remove('opacity-100', 'translate-y-0');
                    t.classList.add('opacity-0', '-translate-y-4'); 
                }, 3000);
            },

            autoResize(el) {
                el.style.height = 'auto'; el.style.height = Math.min(el.scrollHeight, 120) + 'px';
            },

            handleEnter(e) { if(e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); Chat.send(); } }
        };

        const Voice = {
            recognition: null,
            isRecording: false,

            init() {
                if ('webkitSpeechRecognition' in window) {
                    this.recognition = new webkitSpeechRecognition();
                    this.recognition.continuous = false;
                    this.recognition.interimResults = false;
                    this.recognition.lang = 'en-US';

                    this.recognition.onstart = () => {
                        this.isRecording = true;
                        document.getElementById('mic-btn').classList.add('text-primary', 'animate-mic-pulse');
                        UI.toast("Listening...");
                    };

                    this.recognition.onend = () => {
                        this.isRecording = false;
                        document.getElementById('mic-btn').classList.remove('text-primary', 'animate-mic-pulse');
                    };

                    this.recognition.onresult = (event) => {
                        const transcript = event.results[0][0].transcript;
                        const input = document.getElementById('message-input');
                        input.value += (input.value ? ' ' : '') + transcript;
                        UI.autoResize(input);
                    };

                    this.recognition.onerror = (event) => {
                        UI.toast("Voice Error: " + event.error);
                        this.isRecording = false;
                        document.getElementById('mic-btn').classList.remove('text-primary', 'animate-mic-pulse');
                    };
                } else {
                    document.getElementById('mic-btn').style.display = 'none';
                }
            },

            toggle() {
                if (!this.recognition) return UI.toast("Voice not supported");
                if (this.isRecording) this.recognition.stop();
                else this.recognition.start();
                UI.haptic('medium');
            }
        };

        const Chat = {
            abortCtrl: null,
            timers: [],

            getContextHint() {
                const date = new Date();
                const hours = date.getHours();
                const day = date.toLocaleDateString('en-US', { weekday: 'long' });
                let timeOfDay = "day";
                if(hours < 5) timeOfDay = "late night/early morning";
                else if(hours < 12) timeOfDay = "morning";
                else if(hours > 20) timeOfDay = "late evening";
                return `[SYSTEM CONTEXT: It is currently ${day}, ${timeOfDay} (${date.toLocaleTimeString()}). Keep it brief.]`;
            },

            async fetchWithRetry(url, options, retries = 3) {
                for (let i = 0; i < retries; i++) {
                    try {
                        const res = await fetch(url, options);
                        if (!res.ok) {
                            if (res.status === 503) throw new Error('Service Unavailable');
                            if (res.status === 429) throw new Error('Rate Limited');
                            if (res.status >= 400 && res.status < 500) return res; 
                            throw new Error(`HTTP ${res.status}`);
                        }
                        return res;
                    } catch (err) {
                        if (err.name === 'AbortError') throw err; 
                        if (i === retries - 1) throw err; 
                        await new Promise(r => setTimeout(r, 1000 * (i + 1))); 
                    }
                }
            },

            stop() {
                if (this.abortCtrl) this.abortCtrl.abort();
                this.abortCtrl = null;
                this.timers.forEach(clearTimeout);
                this.timers = [];
                UI.showTyping(false);
                Status.setTyping(false);
                State.isStreaming = false; 
            },

            async send() {
                UI.haptic();
                this.stop(); 
                State.followUpDepth = 0;
                State.stopFollowUps = false;

                const input = UI.els.input;
                const txt = input.value.trim();
                if(!txt && !State.attachment) return;
                if(!State.config.apiKey) return UI.toggleSettings();

                input.value = ''; input.style.height = 'auto';
                
                let displayText = txt;
                let activeAttachment = State.attachment;
                if(activeAttachment) { 
                    displayText = `![Image](${activeAttachment.url})\n\n${displayText}`; 
                    UI.clearAttachment(); 
                }

                // Store reply context separately from text
                const replyContext = State.replyingTo ? { ...State.replyingTo } : null;
                UI.cancelReply();

                const msgData = { 
                    role: 'user', 
                    text: displayText, 
                    id: Date.now(), 
                    replyTo: replyContext, // Store Context
                    expiresAt: State.config.sapperMode ? Date.now() + 60000 : null 
                };
                
                const prevRole = State.history[State.history.length -1]?.role;
                const lastMsg = State.history[State.history.length - 1];
                if (!lastMsg || UI.getDateLabel(lastMsg.id) !== UI.getDateLabel(msgData.id)) {
                    UI.renderDateSeparator(UI.getDateLabel(msgData.id));
                }

                State.history.push(msgData);
                State.save();
                
                UI.renderMsg('user', displayText, true, msgData, prevRole);
                UI.appendStatus(true);
                Status.setOnline();

                this.timers.push(setTimeout(() => UI.updateStatusText('Delivered'), 600));
                this.timers.push(setTimeout(() => this.fetchReply(activeAttachment), 1000));
            },

            async fetchReply(attachment) {
                try {
                    this.abortCtrl = new AbortController();
                    const signal = this.abortCtrl.signal;
                    UI.updateStatusText('Seen');
                    
                    await new Promise((resolve, reject) => {
                        const id = setTimeout(resolve, 1500 + Math.random() * 1000);
                        this.timers.push(id);
                        signal.addEventListener('abort', () => { clearTimeout(id); reject(new Error('Aborted')); });
                    });

                    Status.setTyping(true); 
                    UI.showTyping(true); 

                    const contextHint = this.getContextHint();
                    const sysPrompt = State.config.systemPrompt + " " + contextHint;
                    
                    // Inject Reply Context dynamically into Prompt
                    const context = State.history.slice(-12).map(m => {
                        let content = m.text;
                        if(m.text.startsWith('![Image]')) content = m.text.split('\n\n')[1] || "Image Attachment";
                        
                        // Prepension logic
                        if (m.replyTo) {
                            content = `[Replying to: "${m.replyTo.text}"]\n\n${content}`;
                        }
                        
                        return { role: m.role === 'user' ? 'user' : 'model', parts: [{ text: content }] };
                    });

                    const res = await this.fetchWithRetry(`https://generativelanguage.googleapis.com/v1beta/models/${State.config.model}:generateContent?key=${State.config.apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: context,
                            systemInstruction: { parts: [{ text: sysPrompt }] }
                        }),
                        signal: signal 
                    });

                    const data = await res.json();
                    const reply = data.candidates[0].content.parts[0].text;
                    
                    Status.setTyping(false); 
                    UI.showTyping(false); 
                    
                    const aiMsg = { role: 'model', text: reply, id: Date.now(), expiresAt: State.config.sapperMode ? Date.now() + 60000 : null };
                    const prevRole = State.history[State.history.length -1]?.role;
                    State.history.push(aiMsg);
                    State.save();
                    
                    const bubble = UI.renderMsg('model', reply, true, aiMsg, prevRole);
                    await UI.decryptStream(bubble, reply);
                    
                    Status.setOnline();

                    if (!signal.aborted) {
                         this.scheduleChainStep();
                    }

                } catch(e) {
                    if (e.message !== 'Aborted' && e.name !== 'AbortError') {
                        Status.setTyping(false);
                        UI.showTyping(false);
                        UI.toast("Secure Relay Interrupted"); 
                    }
                }
            },

            scheduleChainStep() {
                if (State.followUpDepth >= 3 || State.stopFollowUps) return;
                const delay = 2500 + Math.random() * 3000;
                const id = setTimeout(() => this.executeChainStep(), delay);
                this.timers.push(id);
            },

            async executeChainStep() {
                if (State.followUpDepth >= 3 || State.stopFollowUps) return;

                this.abortCtrl = new AbortController();
                const signal = this.abortCtrl.signal;

                try {
                    Status.setOnline();

                    const context = State.history.slice(-12).map(m => ({ role: m.role === 'user' ? 'user' : 'model', parts: [{ text: m.text }] }));
                    
                    const followUpPrompt = `[SYSTEM: You just sent a message. In a natural text conversation, would you send a short follow-up now (correction, joke, split thought, or "double text")? Reply ||NO|| or the text.]`;
                    
                    const res = await this.fetchWithRetry(`https://generativelanguage.googleapis.com/v1beta/models/${State.config.model}:generateContent?key=${State.config.apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [...context, { role: 'user', parts: [{ text: followUpPrompt }] }] }),
                        signal: signal
                    });

                    const data = await res.json();
                    const text = data.candidates[0].content.parts[0].text.trim();
                    
                    if (text.includes("||NO||") || text.length === 0) {
                        State.stopFollowUps = true; 
                        return;
                    }

                    Status.setTyping(true);
                    UI.showTyping(true);

                    await new Promise((resolve, reject) => {
                         const typingDuration = Math.min(Math.max(text.length * 20, 1000), 4000); 
                         const id = setTimeout(resolve, typingDuration);
                         this.timers.push(id);
                         signal.addEventListener('abort', () => { clearTimeout(id); reject(new Error('Aborted')); });
                    });
                    
                    Status.setTyping(false);
                    UI.showTyping(false);
                    
                    const aiMsg = { role: 'model', text: text, id: Date.now(), expiresAt: State.config.sapperMode ? Date.now() + 60000 : null };
                    State.history.push(aiMsg);
                    State.save();
                    
                    const bubble = UI.renderMsg('model', text, true, aiMsg, 'model'); 
                    await UI.decryptStream(bubble, text);
                    
                    State.followUpDepth++;
                    if(!signal.aborted) this.scheduleChainStep();

                } catch (e) {
                    // FIX: Check for both AbortError name and 'Aborted' message to prevent race condition locking
                    if(e.name !== 'AbortError' && e.message !== 'Aborted') State.stopFollowUps = true;
                }
            }
        };

        const Auth = {
            init() {
                document.getElementById('login-screen').classList.remove('hidden');
                if(State.config.apiKey) Settings.fetchModels(State.config.apiKey);
                Status.startLoop();
            },
            login() {
                UI.haptic();
                const input = document.getElementById('login-pass');
                if(State.isFirstLoad || input.value === State.config.password) {
                    State.config.password = input.value;
                    State.save();
                    UI.showApp();
                } else {
                    input.value = ''; input.classList.add('border-red-500');
                }
            }
        };

        const Status = {
            startLoop() { this.update(); setInterval(() => this.update(), 60000); },
            setTyping(isTyping) {
                const elText = document.getElementById('connection-status');
                if(isTyping) {
                    elText.textContent = "typing...";
                } else {
                    elText.textContent = ""; 
                    this.update();
                }
            },
            update() {
                const diff = (Date.now() - State.config.lastActive) / 1000 / 60;
                const elText = document.getElementById('connection-status');
                const elDot = document.getElementById('status-dot');
                
                if(elText.textContent === "typing...") return;

                if (diff < 5) { elText.textContent = "Online"; elDot.style.backgroundColor = "#34C759"; }
                else if (diff < 20) { elText.textContent = "Idle"; elDot.style.backgroundColor = "#FFD60A"; }
                else { elText.textContent = "Offline"; elDot.style.backgroundColor = "#8E8E93"; }
            },
            setOnline() { State.config.lastActive = Date.now(); State.save(); this.update(); }
        };

        const Settings = {
            async fetchModels(key) {
                try {
                    const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
                    const data = await res.json();
                    if(data.models) {
                        const select = document.getElementById('model-select');
                        select.innerHTML = '';
                        data.models.filter(m => m.supportedGenerationMethods.includes("generateContent")).forEach(m => {
                            const opt = document.createElement('option');
                            opt.value = m.name.split('/')[1]; opt.text = opt.value;
                            select.appendChild(opt);
                        });
                        select.value = State.config.model;
                        document.getElementById('model-status').textContent = "Verified";
                        document.getElementById('model-status').className = "text-[10px] text-green-500";
                    }
                } catch(e) {}
            },
            handleKeyInput(val) { if(val.length > 20) this.fetchModels(val); },
            save() {
                State.config.apiKey = document.getElementById('api-key-input').value.trim();
                State.config.aiName = document.getElementById('ai-name-input').value.trim() || "f0xnet";
                State.config.systemPrompt = document.getElementById('system-prompt').value.trim();
                State.config.model = document.getElementById('model-select').value;
                State.save(); UI.refresh(); UI.toggleSettings(); UI.toast("Settings Saved");
            },
            wipeData() { if(confirm("Wipe everything?")) State.reset(); }
        };

        const Boot = {
            async run() {
                if(!State.isFirstLoad) { document.getElementById('boot-screen').remove(); Auth.init(); return; }
                const logs = ["ESTABLISHING HANDSHAKE...", "ENCRYPTING STORAGE...", "DECRYPTING NODE...", "READY."];
                for(let l of logs) {
                    const d = document.createElement('div'); d.textContent = `> ${l}`;
                    document.getElementById('boot-log').appendChild(d);
                    await new Promise(r => setTimeout(r, 400));
                }
                document.getElementById('boot-screen').style.opacity = '0';
                setTimeout(() => { document.getElementById('boot-screen').remove(); Auth.init(); }, 500);
            }
        };

        document.addEventListener('DOMContentLoaded', () => { State.load(); Boot.run(); Voice.init(); });
    </script>
</body>
</html>


